module array32x3 (address, clock, data, wren, q);
	logic [2:0] memory[31:0]; 
	input logic [4:0] address;
	input logic [2:0] data; 
	input logic wren; 
	input logic clock;
	output logic q; 
	
	always_ff @(posedge clk) begin
		if(wren == 1) begin 	
			memory[address] = data; 
			q <= data; 
		end
		else begin
			q <= memory[address];
		end
		
	end

endmodule

module task2(address, clock ,data, wren, q);
	input logic [4:0] address;
	input logic [2:0] data;
	input logic wren, clock; 
	output logic [2:0] q;
	//post ff, write = wren
	logic [4:0] addressFF;
	logic [2:0] dataFF;
	logic wrenFF;
	
	input logic [9:0] SW;
	output logic [6:0] HEX0, HEX1, HEX2, HEX3, HEX4, HEX5;
	
	
	always_ff @(posedge clock) begin
			addressFF <= address;
			dataFF <= data; 
			wrenFF <= wren;
	end
	
	

endmodule

	
module task2tb();

 logic [4:0] address;
 logic[2:0] data;
 logic wren;
 logic [2:0] q;
 logic clock; 
 
 task2b dut (.*);
 
 parameter CLOCK_PERIOD = 100;
	initial begin 
		clock <= 0; 
		forever #(CLOCK_PERIOD/2) clock <= ~clock;
	end

	initial begin
		wren <= 1; data <= 3'b001; address <= 4'b0001; @(posedge clock);
		                           @(posedge clock);
		//show that it reads when wren = 0
		wren <= 0; data <= 3'b111; @(posedge clock);
		$stop;
	end
endmodule
